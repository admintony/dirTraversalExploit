package main

import (
	"errors"
	"flag"
	"fmt"
	"net/http"
	"net/http/httputil"
	"os"
	"regexp"
	"strconv"
	"strings"
	"time"
)

var Url string

func parseFlag() {
	// 定义一个字符串变量，用于存储命令行参数的值
	// var url string
	// 通过 flag 包解析命令行参数
	flag.StringVar(&Url, "url", "u", "URL parameter")

	// 解析命令行参数
	flag.Parse()

	// 如果未提供 URL 参数，则输出用法说明
	if Url == "" {
		fmt.Println("Usage: go run main.go --url=<URL>")
		os.Exit(0)
	}
}

func makeRequest(url string) []byte {
	req, _ := http.NewRequest(http.MethodGet, url, nil)
	req.Header.Add("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36")
	client := http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	s, err := httputil.DumpResponse(resp, true)
	return s
}

func parseHtml(content []byte) map[string]string {
	re := regexp.MustCompile(`(?i)alt="\[(\w+)\]"></td><td><a href="([^"]+)">`)
	substr := re.FindAllSubmatch(content, -1)
	result := make(map[string]string)
	for _, value := range substr {
		result[string(value[2])] = string(value[1])
	}
	return result
}

func merge(arr1, arr2 []string) []string {
	for _, value := range arr2 {
		arr1 = append(arr1, value)
	}
	return arr1
}

func getURL(url string) []string {
	content := makeRequest(url)
	urlMap := parseHtml(content)
	var urls []string
	for key, value := range urlMap {
		op := strings.ToLower(value)
		//fmt.Println(key, value)
		switch op {
		case "txt":
			urls = append(urls, strings.Trim(url, "/")+"/"+key)
		case "dir":
			tmpURLArr := getURL(strings.Trim(url, "/") + "/" + key)
			urls = merge(urls, tmpURLArr)
		}
	}
	return urls
}

func isUnAuth(url string) (code, length, title string) {
	req, _ := http.NewRequest(http.MethodGet, url, nil)
	req.Header.Add("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36")
	client := http.Client{
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return errors.New("Disable redirect")
		},
	}
	resp, err := client.Do(req)
	if err != nil {
		if strings.Contains(err.Error(), "Disable redirect") {
			return "302", "-1", ""
		} else {
			panic(err)
		}
	}
	defer resp.Body.Close()
	statusCode := strconv.Itoa(resp.StatusCode)
	contentLength := strconv.Itoa(int(resp.ContentLength))
	content, _ := httputil.DumpResponse(resp, true)
	title = parseTitle(content)

	return statusCode, contentLength, title
}

func createDirIfNotExist(dirPath string) error {
	// 检查目录是否存在
	if _, err := os.Stat(dirPath); os.IsNotExist(err) {
		// 创建目录
		if err := os.MkdirAll(dirPath, 0755); err != nil {
			return err
		}
	}
	return nil
}

func writeResult(content string, timeString string) error {
	_ = createDirIfNotExist("output/")
	filename := "output/output_" + timeString + ".csv"
	file, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer file.Close()
	// 写入数据行并检查任何错误
	_, err = file.WriteString(content)
	if err != nil {
		return err
	}
	return nil
}

func parseTitle(content []byte) string {
	re := regexp.MustCompile(`<title>(.*)</title>`)
	titles := re.FindAllSubmatch(content, -1)
	var title string
	if len(titles) == 0 {
		title = ""
	} else {
		title = string(titles[0][1])
	}
	return title
}

func banner() {
	banner := ` ______   ___   ______      _______  ______    _______  __   __  _______  ______    _______  _______  ___        _______  __   __  _______  ___      _______  ___   _______ 
|      | |   | |    _ |    |       ||    _ |  |   _   ||  | |  ||       ||    _ |  |       ||   _   ||   |      |       ||  |_|  ||       ||   |    |       ||   | |       |
|  _    ||   | |   | ||    |_     _||   | ||  |  |_|  ||  |_|  ||    ___||   | ||  |  _____||  |_|  ||   |      |    ___||       ||    _  ||   |    |   _   ||   | |_     _|
| | |   ||   | |   |_||_     |   |  |   |_||_ |       ||       ||   |___ |   |_||_ | |_____ |       ||   |      |   |___ |       ||   |_| ||   |    |  | |  ||   |   |   |  
| |_|   ||   | |    __  |    |   |  |    __  ||       ||       ||    ___||    __  ||_____  ||       ||   |___   |    ___| |     | |    ___||   |___ |  |_|  ||   |   |   |  
|       ||   | |   |  | |    |   |  |   |  | ||   _   | |     | |   |___ |   |  | | _____| ||   _   ||       |  |   |___ |   _   ||   |    |       ||       ||   |   |   |  
|______| |___| |___|  |_|    |___|  |___|  |_||__| |__|  |___|  |_______||___|  |_||_______||__| |__||_______|  |_______||__| |__||___|    |_______||_______||___|   |___|  

Author:Admintony
GitHub:https://github.com/admintony/dirTraversalExploit
`
	fmt.Println(banner)
}

func main() {
	banner()
	parseFlag()
	now := time.Now()
	timeString := string(now.Format("20060102150405"))
	urls := getURL(Url)
	for _, value := range urls {
		statusCode, contentLength, title := isUnAuth(value)
		fmt.Printf("[+]URL: %s , statusCode: %s , contentLength: %s \n", value, statusCode, contentLength)
		content := value + "," + statusCode + "," + contentLength + "," + title + "\n"
		_ = writeResult(content, timeString)
	}
}
